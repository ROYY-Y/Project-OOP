-- Vector
oop::vector<int> v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);

    cout << v[0] << endl;
    cout << v[2] << endl;
    cout << v[v.size()-1] << endl;
    cout << "------------\n";
    for(auto &e: v){
        cout << e << endl;
    }

    v.insert(v.begin()+1, 5);
    cout << "------Insert------\n";
    for(auto &e: v){
        cout << e << endl;
    }

    cout << "------Erase------\n";

    v.erase(v.end()-1);

    for(auto &e: v){
        cout << e << endl;
    }


    cout << "------Clear------\n";
    v.clear();

-- Queue

oop::queue<int> q;
    q.push(10);
    q.push(20);
    q.push(30);
    q.push(40);
    q.push(50);
    
    while(!q.empty()){
        cout << q.front();
        cout << endl;
        q.pop();
    }

-- Stack

oop::stack<int> s;
    s.push(10);
    s.push(15);
    s.push(3);
    s.push(4);
    s.push(50);

    while(!s.empty()){
        cout << s.top();
        cout << endl;
        s.pop();
    }


-- Priority_queue
oop::priority_queue<int> pq;
    pq.push(10);
    pq.push(20);
    pq.push(30);
    pq.push(40); 

    while(!pq.empty()){
        std::cout << pq.top() << std::endl; 
        pq.pop();
    }

    return 0;

-- AVL TREE

    oop::AVLTree<int> tree;

    cout << "Insert 10, 20, 30, 40, 50, 25" << endl;

    tree.insert(10);
    tree.insert(20);
    tree.insert(30);
    tree.insert(40);
    tree.insert(50);
    tree.insert(25);

    cout << "Size = " << tree.size() << endl;
    cout << "Height = " << tree.height() << endl;

    // test contains
    cout << "Contains 30? " << (tree.contains(30) ? "YES" : "NO") << endl;
    cout << "Contains 99? " << (tree.contains(99) ? "YES" : "NO") << endl;

    // test find
    int* ptr = tree.find(25);
    if (ptr) {
        cout << "Find(25) = " << ptr << endl;
    } else {
        cout << "Find(25) = NOT FOUND" << endl;
    }

    // test removing
    cout << "\nRemove 40" << endl;
    tree.remove(40);

    cout << "Contains 40? " << (tree.contains(40) ? "YES" : "NO") << endl;
    cout << "Size = " << tree.size() << endl;
    cout << "Height = " << tree.height() << endl;

    cout << "\nRemove 10, 20, 25" << endl;
    tree.remove(10);
    tree.remove(20);
    tree.remove(25);

    cout << "Size = " << tree.size() << endl;
    cout << "Empty? " << (tree.empty() ? "YES" : "NO") << endl;

    // Find something that doesn't exist
    ptr = tree.find(999);
    cout << "Find(999) = " << (ptr ? to_string(*ptr) : string("NOT FOUND")) << endl;

    return 0;

-- Set
    oop::Set<int> s;

    cout << "== Test Insert ==" << endl;

    cout << "Insert 10: " << s.insert(10) << endl;   // 1
    cout << "Insert 20: " << s.insert(20) << endl;   // 1
    cout << "Insert 30: " << s.insert(30) << endl;   // 1
    cout << "Insert 10 again: " << s.insert(10) << endl; // 0 (duplicate)

    cout << "Size = " << s.size() << endl; // 3

    cout << "\n== Test Contains ==" << endl;
    cout << "Contains 20? " << (s.contains(20) ? "YES" : "NO") << endl;
    cout << "Contains 99? " << (s.contains(99) ? "YES" : "NO") << endl;

    cout << "\n== Test Find ==" << endl;
    int* p = s.find(30);
    if (p)
        cout << "Find(30) = " << *p << endl;
    else
        cout << "Find(30) = NOT FOUND" << endl;

    p = s.find(500);
    if (p)
        cout << "Find(500) = " << *p << endl;
    else
        cout << "Find(500) = NOT FOUND" << endl;

    cout << "\n== Test Erase ==" << endl;
    cout << "Erase 20: " << s.erase(20) << endl; // 1
    cout << "Erase 20 again: " << s.erase(20) << endl; // 0 (no longer exists)
    cout << "Erase 99: " << s.erase(99) << endl; // 0

    cout << "Size = " << s.size() << endl;

    cout << "\n== Test Empty ==" << endl;
    cout << "Empty? " << (s.empty() ? "YES" : "NO") << endl;

    cout << "\nErasing all..." << endl;
    s.erase(10);
    s.erase(30);

    cout << "Empty? " << (s.empty() ? "YES" : "NO") << endl;

-- Map

    oop::Map<int, string> mp;

    cout << "== Test Insert ==" << endl;
    mp.insert(10, "apple");
    mp.insert(20, "banana");
    mp.insert(30, "cat");

    cout << "Contains 20? " << (mp.contains(20) ? "YES" : "NO") << endl;
    cout << "Contains 99? " << (mp.contains(99) ? "YES" : "NO") << endl;

    cout << "\n== Test get(key) ==" << endl;
    string* p = mp.get(30);
    if (p) cout << "get(30) = " << *p << endl;
    else   cout << "get(30) = NOT FOUND" << endl;

    p = mp.get(999);
    if (p) cout << "get(999) = " << *p << endl;
    else   cout << "get(999) = NOT FOUND" << endl;

    cout << "\n== Test operator[] ==" << endl;

    cout << "mp[10] = " << mp[10] << endl; 
    cout << "mp[20] = " << mp[20] << endl; 

    cout << "mp[50] = " << mp[50] << endl;  

    mp[20] = "blueberry"; //
    cout << "mp[20] updated = " << mp[20] << endl;

    cout << "\n== Test Insert Duplicate ==" << endl;
    mp.insert(10, "dog"); 
    cout << "mp[10] = " << mp[10] << "  (should still be 'apple')" << endl;

    cout << "\n== Loop Test ==" << endl;

    for (int k : {10, 20, 30, 50}) {
        cout << k << " -> " << mp[k] << endl;
    }



--DirectedGraph
oop::DirectedGraph g;

    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);
    g.addEdge(3, 4);
    g.addEdge(4, 1);

    std::cout << "Graph:\n";
    g.printGraph();

    std::cout << "BFS from 1: ";
    g.BFS(1);

    std::cout << "DFS from 1: ";
    g.DFS(1);

    std::cout << "Has edge 1->2? " << g.hasEdge(1, 2) << "\n";
    g.removeEdge(1, 2);
    std::cout << "Has edge 1->2 after removal? " << g.hasEdge(1, 2) << "\n";

    g.removeVertex(4);
    std::cout << "Graph after removing vertex 4:\n";
    g.printGraph();